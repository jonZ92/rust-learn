/*
 * @author jon 2021:08:29
 */

/*                            什么是所有权">什么是所有权？

Rust 的核心功能（之一）是 所有权（ownership）。虽然该功能很容易解释，但它对语言的其他部分有着深刻的影响。
所有运行的程序都必须管理其使用计算机内存的方式。一些语言中具有垃圾回收机制，在程序运行时不断地寻找不再使用的内存；
在另一些语言中，程序员必须亲自分配和释放内存。Rust 则选择了第三种方式：通过所有权系统管理内存，
编译器在编译时会根据一系列的规则进行检查。在运行时，所有权系统的任何功能都不会减慢程序。
因为所有权对很多程序员来说都是一个新概念，需要一些时间来适应。好消息是随着你对 Rust 和所有权系统的规则越来越有经验，
你就越能自然地编写出安全和高效的代码。持之以恒！
当你理解了所有权，你将有一个坚实的基础来理解那些使 Rust 独特的功能。在本章中，你将通过完成一些示例来学习所有权，
这些示例基于一个常用的数据结构：字符串。
 */

/*                    所有权规则

            首先，让我们看一下所有权的规则。当我们通过举例说明时，请谨记这些规则：

            1.Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。
            2.值在任一时刻有且只有一个所有者。
            3.当所有者（变量）离开作用域，这个值将被丢弃。
 */


/*                                    栈（Stack）与堆（Heap）

在很多语言中，你并不需要经常考虑到栈与堆。不过在像 Rust 这样的系统编程语言中，值是位于栈上还是堆上在更大程度上影响了语言的行为以及为何必须做出这样的抉择。
我们会在本章的稍后部分描述所有权与栈和堆相关的内容，所以这里只是一个用来预热的简要解释。
栈和堆都是代码在运行时可供使用的内存，但是它们的结构不同。栈以放入值的顺序存储值并以相反顺序取出值。这也被称作 后进先出（last in, first out）。
想象一下一叠盘子：当增加更多盘子时，把它们放在盘子堆的顶部，当需要盘子时，也从顶部拿走。
不能从中间也不能从底部增加或拿走盘子！增加数据叫做 进栈（pushing onto the stack），而移出数据叫做 出栈（popping off the stack）。
栈中的所有数据都必须占用已知且固定的大小。在编译时大小未知或大小可能变化的数据，要改为存储在堆上。堆是缺乏组织的：当向堆放入数据时，
你要请求一定大小的空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 指针（pointer）。
这个过程称作 在堆上分配内存（allocating on the heap），有时简称为 “分配”（allocating）。
将数据推入栈中并不被认为是分配。因为指针的大小是已知并且固定的，你可以将指针存储在栈上，不过当需要实际数据时，必须访问指针。
想象一下去餐馆就座吃饭。当进入时，你说明有几个人，餐馆员工会找到一个够大的空桌子并领你们过去。如果有人来迟了，他们也可以通过询问来找到你们坐在哪。
入栈比在堆上分配内存要快，因为（入栈时）操作系统无需为存储新数据去搜索内存空间；其位置总是在栈顶。相比之下，
在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，并接着做一些记录为下一次分配做准备。
访问堆上的数据比访问栈上的数据慢，因为必须通过指针来访问。现代处理器在内存中跳转越少就越快（缓存）。继续类比，
假设有一个服务员在餐厅里处理多个桌子的点菜。在一个桌子报完所有菜后再移动到下一个桌子是最有效率的。
从桌子 A 听一个菜，接着桌子 B 听一个菜，然后再桌子 A，然后再桌子 B 这样的流程会更加缓慢。出于同样原因，
处理器在处理的数据彼此较近的时候（比如在栈上）比较远的时候（比如可能在堆上）能更好的工作。在堆上分配大量的空间也可能消耗时间。
当你的代码调用一个函数时，传递给函数的值（包括可能指向堆上数据的指针）和函数的局部变量被压入栈中。当函数结束时，这些值被移出栈。
跟踪哪部分代码正在使用堆上的哪些数据，最大限度的减少堆上的重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间，
这些问题正是所有权系统要处理的。一旦理解了所有权，你就不需要经常考虑栈和堆了，不过明白了所有权的存在就是为了管理堆数据，能够帮助解释为什么所有权要以这种方式工作。

 */

//所有权
pub mod ownership1 {
    pub fn test() {
        //方法内有效，方法外无效，即使一参数形式传入，也是无效，不能修改其值。
        let _num_ = 8;//栈上申请内存

        let _str_ = String::new();//堆上申请内存
        let _from_ = String::from("hello");//堆上申请内存
        let _s2_ = _from_;//此时_from_变量失效，所有权给了 _s2_le。

        // 如果不想让_from_ 所有权失效，可以使用克隆
        let _from1_ = String::from("hello");
        let _s3_ = _from1_.clone();//克隆 _from1_  堆上地址，此时堆内存上有两个 存有 hello 值得内存


        let _x_ = 5;
        let _y_ = _x_;//此时_x_ 所有权还在，与上述堆拷贝不同，编译器已知大小拷贝，所以不存在 _x_失效
        println!("_x_ :{}", _x_);
        println!("普通作用域变量");
    }
}


//借用和引用
pub mod ownership2 {
    //引用 操作
    pub fn test(_stre:&String)->usize {
        //_stre.push_str("sss"); //引用，只是使用，不可修改值
        _stre.len()
    }

    pub fn test1(num_:u32)->u32{

        println!("num_ is :{}",num_);
        let nn_=num_+1;
        nn_
    }

    pub fn test2(num1_:&str)->usize{
        num1_.len()
    }
}